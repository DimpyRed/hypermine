Index: common/src/worldgen.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- common/src/worldgen.rs	(date 1594800959000)
+++ common/src/worldgen.rs	(date 1597106094000)
@@ -60,13 +60,23 @@
     }
 }
 
+pub struct CliffState {
+    is_cliff: bool,
+    generates_cliff: bool,
+    generates_cliff_side: Side,
+}
+
 pub struct NodeState {
     kind: NodeStateKind,
     surface: Plane<f64>,
     road_state: NodeStateRoad,
     spice: u64,
+    cliff_data: CliffState,
     enviro: EnviroFactors,
 }
+
+const A_ADJACENT: [Side; 5] = [Side::B, Side::C, Side::D, Side::E, Side::I];
+
 impl NodeState {
     pub fn root() -> Self {
         Self {
@@ -74,6 +84,11 @@
             surface: Plane::from(Side::A),
             road_state: NodeStateRoad::ROOT,
             spice: 0,
+            cliff_data: CliffState {
+                is_cliff: false,
+                generates_cliff: false,
+                generates_cliff_side: Side::A, // dummy
+            },
             enviro: EnviroFactors {
                 max_elevation: 0.0,
                 temperature: 0.0,
@@ -96,19 +111,57 @@
         let mut d = graph
             .descenders(node)
             .map(|(s, n)| (s, &graph.get(n).as_ref().unwrap().state));
-        let enviro = match (d.next(), d.next()) {
+
+        let mut rng = rand_pcg::Pcg64Mcg::seed_from_u64(spice + 1); // cheeky hash
+        let generates_cliff_side = A_ADJACENT[rng.gen_range(0, 4)]; // hard-coded to include all elements in A_ADJACENT
+
+        let enviro;
+        let cliff_data;
+        match (d.next(), d.next()) {
             (Some(_), None) => {
                 let parent_side = graph.parent(node).unwrap();
                 let parent_node = graph.neighbor(node, parent_side).unwrap();
                 let parent_state = &graph.get(parent_node).as_ref().unwrap().state;
-                EnviroFactors::varied_from(parent_state.enviro, spice)
+                enviro = EnviroFactors::varied_from(parent_state.enviro, spice);
+                let is_cliff = {
+                    if parent_state.cliff_data.generates_cliff
+                        && (parent_state.cliff_data.generates_cliff_side == side)
+                        && (parent_state.kind == Land)
+                    {
+                        !parent_state.cliff_data.is_cliff
+                    } else {
+                        parent_state.cliff_data.is_cliff
+                    }
+                };
+
+                let generates_cliff = match is_cliff {
+                    true => rng.gen_ratio(4, 5),
+                    false => rng.gen_ratio(1, 3),
+                };
+
+                cliff_data = CliffState {
+                    is_cliff,
+                    generates_cliff,
+                    generates_cliff_side,
+                };
             }
             (Some((a_side, a_state)), Some((b_side, b_state))) => {
                 let ab_node = graph
                     .neighbor(graph.neighbor(node, a_side).unwrap(), b_side)
                     .unwrap();
                 let ab_state = &graph.get(ab_node).as_ref().unwrap().state;
-                EnviroFactors::continue_from(a_state.enviro, b_state.enviro, ab_state.enviro)
+                enviro =
+                    EnviroFactors::continue_from(a_state.enviro, b_state.enviro, ab_state.enviro);
+
+                let is_cliff = a_state.cliff_data.is_cliff
+                    ^ b_state.cliff_data.is_cliff
+                    ^ ab_state.cliff_data.is_cliff;
+                let generates_cliff = rng.gen_ratio(1, 3);
+                cliff_data = CliffState {
+                    is_cliff,
+                    generates_cliff,
+                    generates_cliff_side,
+                };
             }
             _ => unreachable!(),
         };
@@ -124,6 +177,7 @@
                 _ => side * self.surface,
             },
             road_state: child_road,
+            cliff_data,
             spice,
             enviro,
         }
@@ -143,6 +197,7 @@
     is_road: bool,
     /// Whether this chunk contains a section of the road's supports
     is_road_support: bool,
+    is_cliff: bool,
     node_spice: u64,
 }
 
@@ -161,6 +216,7 @@
                 && ((state.road_state == East) || (state.road_state == West)),
             is_road_support: ((state.kind == Land) || (state.kind == DeepLand))
                 && ((state.road_state == East) || (state.road_state == West)),
+            is_cliff: state.cliff_data.is_cliff,
             node_spice: state.spice,
         })
     }
@@ -200,7 +256,13 @@
                     // otherwise the terracing fails to be (nonstrictly) monotonic
                     // and the terrain gets trenches ringing around its cliffs.
                     let elev_pre_noise =
-                        elev_pre_terracing + 0.6 * terracing_small + 0.4 * terracing_big;
+                        elev_pre_terracing + 0.6 * terracing_small + 0.4 * terracing_big + {
+                            if self.is_cliff {
+                                14.0
+                            } else {
+                                0.0
+                            }
+                        };
 
                     // initial value dist_pre_noise is the difference between the voxel's distance
                     // from the guiding plane and the voxel's calculated elev value. It represents
@@ -405,7 +467,7 @@
         // Maximum difference between elevations at the center of a chunk and any other point in the chunk
         // TODO: Compute what this actually is, current value is a guess! Real one must be > 0.6
         // empirically.
-        const ELEVATION_MARGIN: f64 = 0.7;
+        /*const ELEVATION_MARGIN: f64 = 0.7;
         let center_elevation = self
             .surface
             .distance_to_chunk(self.chunk, &na::Vector3::repeat(0.5));
@@ -420,7 +482,7 @@
             // The whole chunk is underground
             // TODO: More accurate VoxelData
             return VoxelData::Solid(Material::Dirt);
-        }
+        }*/
 
         let mut voxels = VoxelData::Solid(Material::Void);
         let mut rng = rand_pcg::Pcg64Mcg::seed_from_u64(hash(self.node_spice, self.chunk as u64));
